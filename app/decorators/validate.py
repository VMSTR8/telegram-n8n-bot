from functools import wraps
from typing import Callable, Any, Awaitable
from aiogram.types import Message
from app.utils import validate_callsign_format


class CallsignDecorators:
    """
    Class containing decorators for callsign validation.
    Works with methods of classes, not regular functions.
    """

    @staticmethod
    def validate_callsign_create(func: Callable[..., Awaitable[Any]]) -> Callable[..., Awaitable[Any]]:
        """
        Decorator for validating callsign in the /reg command.
        Checks that the callsign meets the requirements:
        - Only Latin letters
        - Length from 1 to 20 characters
        - No digits, special characters, or spaces
        - Callsign must be unique
        If the callsign is invalid, sends an error message and does not call the main function

        :param func: Function to be decorated
        :return: Wrapped asynchronous function with the same arguments 
        as the original function
        """
        @wraps(func)
        async def wrapper(self, message: Message, *args: Any, **kwargs: Any) -> Any:
            if not message.text:
                await message.reply(
                    text='‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã.\n'
                         '–û—Ç–ø—Ä–∞–≤—å –∫–æ–º–∞–Ω–¥—É `/reg –ø–æ–∑—ã–≤–Ω–æ–π`\n'
                         '–ö–æ–º–∞–Ω–¥–∞ –Ω–µ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –Ω–∏—á–µ–≥–æ, –∫—Ä–æ–º–µ —Ç–µ–∫—Å—Ç–∞!',
                    parse_mode='Markdown'
                )
                return

            command_parts = message.text.split()
            if len(command_parts) != 2:
                await message.reply(
                    text='‚ùå –ù—É–∂–Ω–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å —Å–≤–æ–π –ø–æ–∑—ã–≤–Ω–æ–π '
                         '(–æ–¥–Ω–æ —Å–ª–æ–≤–æ) '
                         '–≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º –ø–æ–ª–µ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã.\n\n'
                         '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: `/reg –ø–æ–∑—ã–≤–Ω–æ–π`\n\n'
                         '–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –ø–æ–∑—ã–≤–Ω–æ–º—É:\n'
                         'üî§ –¢–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã\n'
                         'üìè –î–ª–∏–Ω–∞ –æ—Ç 1 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤\n'
                         'üö´ –ë–µ–∑ —Ü–∏—Ñ—Ä, —Å–ø–µ—Ü —Å–∏–º–≤–æ–ª–æ–≤ –∏ –ø—Ä–æ–±–µ–ª–æ–≤\n'
                         'üÜî –ü–æ–∑—ã–≤–Ω–æ–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º',
                    parse_mode='Markdown'
                )
                return
            
            callsign = command_parts[1].strip()

            validation_result = validate_callsign_format(callsign)
            if not validation_result.is_valid:
                await message.reply(
                    text=f'‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–æ–∑—ã–≤–Ω–æ–≥–æ.\n\n'
                         f'{validation_result.error_message}\n\n'
                         f'–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: `/reg –ø–æ–∑—ã–≤–Ω–æ–π`\n\n'
                         f'–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –ø–æ–∑—ã–≤–Ω–æ–º—É:\n'
                         f'üî§ –¢–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã\n'
                         f'üìè –î–ª–∏–Ω–∞ –æ—Ç 1 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤\n'
                         f'üö´ –ë–µ–∑ —Ü–∏—Ñ—Ä, —Å–ø–µ—Ü —Å–∏–º–≤–æ–ª–æ–≤ –∏ –ø—Ä–æ–±–µ–ª–æ–≤\n'
                         f'üÜî –ü–æ–∑—ã–≤–Ω–æ–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º',
                    parse_mode='Markdown'
                )
                return

            return await func(self, message, callsign, *args, **kwargs)

        return wrapper

    @staticmethod
    def validate_callsign_update(func: Callable[..., Awaitable[Any]]) -> Callable[..., Awaitable[Any]]:
        """
        Decorator for validating callsign in the /update command.
        If a callsign is provided, checks that it meets the requirements:
        - Only Latin letters
        - Length from 1 to 20 characters
        - No digits, special characters, or spaces
        - Callsign must be unique
        If the callsign is invalid, sends an error message and does not call the main function

        :param func: Function to be decorated
        :return: Wrapped asynchronous function with the same arguments 
        as the original function
        """
        @wraps(func)
        async def wrapper(self, message: Message, *args: Any, **kwargs: Any) -> Any:
            if not message.text:
                await message.reply(
                    text='‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã.\n'
                         '–û—Ç–ø—Ä–∞–≤—å –∫–æ–º–∞–Ω–¥—É `/update –ø–æ–∑—ã–≤–Ω–æ–π`\n'
                         '–ö–æ–º–∞–Ω–¥–∞ –Ω–µ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –Ω–∏—á–µ–≥–æ, –∫—Ä–æ–º–µ —Ç–µ–∫—Å—Ç–∞!',
                    parse_mode='Markdown'
                )
                return

            command_parts = message.text.split()
            
            if len(command_parts) >= 2:
                
                callsign = command_parts[1].strip()

                validation_result = validate_callsign_format(callsign)

                if not validation_result.is_valid:
                    await message.reply(
                        text=f'‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–æ–∑—ã–≤–Ω–æ–≥–æ.\n\n'
                            f'{validation_result.error_message}\n\n'
                            f'–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: `/update –ø–æ–∑—ã–≤–Ω–æ–π`\n\n'
                            f'–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –ø–æ–∑—ã–≤–Ω–æ–º—É:\n'
                            f'üî§ –¢–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã\n'
                            f'üìè –î–ª–∏–Ω–∞ –æ—Ç 1 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤\n'
                            f'üö´ –ë–µ–∑ —Ü–∏—Ñ—Ä, —Å–ø–µ—Ü —Å–∏–º–≤–æ–ª–æ–≤ –∏ –ø—Ä–æ–±–µ–ª–æ–≤\n'
                            f'üÜî –ü–æ–∑—ã–≤–Ω–æ–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º',
                        parse_mode='Markdown'
                    )
                    return

            return await func(self, message, *args, **kwargs)

        return wrapper
